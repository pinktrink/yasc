var fs = require('fs'),
	cluster = require('cluster'),
	cpus = require('os').cpus().length,
	packs = {},
	conf = {},
	files = {},
	numWorkers = 0,
	autoGenerated = [];

cluster.setupMaster({
	exec : 'worker.js'
});

setInterval(function(){}, 1000000);  //Keep app alive.

module.exports = {
	parseConfig : function(loc, cb){
		if(!loc){
			loc = process.env.PWD + '/yasc.json';
		}
		
		fs.readFile(loc, function(err, data){
			if(err){
				throw err;
			}
			
			conf = JSON.parse(data);
			
			if(cb){
				cb({
					conf : conf
				});
			}
		});
	},
	config : function(config){
		conf = config;
	},
	loadPacks : function(){
		var packsNeeded = [];
		
		for(var d in conf){
			(function getPacks(obj){
				if(obj.hasOwnProperty('use')){
					if(!~packsNeeded.indexOf(obj.use)){
						packsNeeded.push(obj.use);
					}
					
					if(obj.hasOwnProperty('then')){
						getPacks(obj.then);
					}
				}
			})(conf[d]);
		}
		
		for(var i = 0, j = packsNeeded.length; i < j; i++){
			try{
				packs[packsNeeded[i]] = require('./packs/' + packsNeeded[i]);
			}catch(e){
				throw 'Pack does not exist: ' + packsNeeded[i];
			}
		}
	},
	newWorker : function(cb){
		if(!cb){
			return;
		}
		
		(function checkWorkers(){
			var worker;
			
			if(Object.keys(cluster.workers).length === cpus){
				process.nextTick(checkWorkers);
			}else{
				worker = cluster.fork();
				
				worker.on('online', function(){
					cb(worker);
				});
			}
		})();
	},
	perform : function perform(cnf, file){
		var self = this;
		
		if(files.hasOwnProperty(file)){
			files[file].kill('SIGKILL');
			
			delete files[file];
		}
		
		this.newWorker(function(worker){
			files[file] = worker;
			
			fs.readFile(file, function(err, data){
				if(err){
					worker.kill('SIGKILL');
					
					delete files[file];
					
					return;
				}
				
				worker.send({
					pack : cnf.use,
					data : data.toString()
				});
			});
			
			worker.on('message', function(data){
				var newFile = cnf.out.replace(/\{\{name\}\}/gi, file.substr(0, file.lastIndexOf('.')));
				
				autoGenerated.push(newFile);
				
				fs.writeFile(newFile, data);
				
				worker.kill('SIGKILL');
				
				delete files[file];
				
				if(cnf.hasOwnProperty('then')){
					perform.call(self, cnf.then, newFile)
				}
			});
		});
	},
	watch : function(){
		var self = this;
		
		for(var piece in conf){
			(function(dir){
				var fullDir = dir + (dir[dir.length - 1] === '/' ? '' : '/');
				
				fs.watch(fullDir, function(action, file){
					if((new RegExp(conf[dir].for)).test(file) && !~autoGenerated.indexOf(fullDir + file)){
						switch(action){
							case 'change':
								self.perform(conf[dir], fullDir + file);
								
								break;
							
							case 'rename':
								fs.exists(dir + file, function(exists){
									var index = -1;
									if(exists){
										self.perform(conf[dir], fullDir + file);
									}else{
										if(~(index = autoGenerated.indexOf(fullDir + file))){
											delete autoGenerated[index];
										}
									}
								});
								
								break;
						}
					}
				});
			})(piece);
		}
	}
}
